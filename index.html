<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Incision</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; }
    canvas { display: block; }
    #hint {
      position: fixed; bottom: 40px; width: 100%;
      text-align: center; color: rgba(255,255,255,0.2);
      font-family: sans-serif; font-size: 13px; letter-spacing: 0.14em;
      pointer-events: none; transition: opacity 2s ease;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="hint">drag to cut</div>
  <script>
    const canvas = document.getElementById('c');
    const ctx    = canvas.getContext('2d');
    const hint   = document.getElementById('hint');

    // Offscreen canvas: photo with wound areas erased
    const imgCvs = document.createElement('canvas');
    const imgCtx = imgCvs.getContext('2d');

    // Declare all shared variables upfront (no TDZ hazards)
    let W, H;
    let imgScale = 0, imgW, imgH, imgX, imgY;
    let activeCut = null;
    let hintGone  = false;
    let t = 0;

    function resize() {
      W = canvas.width  = imgCvs.width  = window.innerWidth;
      H = canvas.height = imgCvs.height = window.innerHeight;
      imgScale = 0;
    }
    resize();
    window.addEventListener('resize', resize);

    // Photo
    const img = new Image();
    img.src = 'source.png';

    // ── Seething background ───────────────────────────────────────────────
    const blobs = [];
    for (let i = 0; i < 9; i++) {
      blobs.push({
        x:     Math.random() * window.innerWidth,
        y:     Math.random() * window.innerHeight,
        vx:    (Math.random() - 0.5) * 0.5,
        vy:    (Math.random() - 0.5) * 0.5,
        r:     0,   // set below after W/H known
        phase: Math.random() * Math.PI * 2,
        freq:  0.015 + Math.random() * 0.02,
      });
    }
    // Set radii now that W/H are known
    blobs.forEach(b => { b.r = (0.12 + Math.random() * 0.22) * Math.min(W, H); });

    function drawSeething() {
      ctx.fillStyle = '#080000';
      ctx.fillRect(0, 0, W, H);
      for (const b of blobs) {
        b.x += b.vx;
        b.y += b.vy;
        b.phase += b.freq;
        if (b.x < -b.r) b.vx =  Math.abs(b.vx);
        if (b.x > W+b.r) b.vx = -Math.abs(b.vx);
        if (b.y < -b.r) b.vy =  Math.abs(b.vy);
        if (b.y > H+b.r) b.vy = -Math.abs(b.vy);
        const p = 0.35 + 0.65 * Math.abs(Math.sin(b.phase));
        const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
        g.addColorStop(0,    'rgba(' + ((120 + 80*p)|0) + ',0,0,' + (0.65*p).toFixed(2) + ')');
        g.addColorStop(0.4,  'rgba(' + ((50  + 30*p)|0) + ',0,0,' + (0.35*p).toFixed(2) + ')');
        g.addColorStop(1,    'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);
      }
    }

    // ── Image layer with wounds ───────────────────────────────────────────
    function drawImageLayer() {
      if (!img.complete || !img.naturalWidth) return;
      if (!imgScale) {
        imgScale = Math.max(W / img.naturalWidth, H / img.naturalHeight);
        imgW = img.naturalWidth  * imgScale;
        imgH = img.naturalHeight * imgScale;
        imgX = (W - imgW) / 2;
        imgY = (H - imgH) / 2;
      }
      imgCtx.clearRect(0, 0, W, H);
      imgCtx.drawImage(img, imgX, imgY, imgW, imgH);

      // Erase wound areas to reveal seething beneath
      imgCtx.globalCompositeOperation = 'destination-out';
      for (const cut of cuts) eraseWound(cut.points, cut.age / CUT_LIFE);
      if (activeCut)          eraseWound(activeCut.points, 0);
      imgCtx.globalCompositeOperation = 'source-over';

      ctx.drawImage(imgCvs, 0, 0);
    }

    function eraseWound(pts, heal) {
      const n = pts.length;
      if (n < 2) return;
      imgCtx.lineCap = 'round';
      imgCtx.lineJoin = 'round';
      imgCtx.strokeStyle = 'rgba(0,0,0,1)';
      for (let i = 1; i < n; i++) {
        const taper = Math.min(i / 4, 1, (n - i) / 4);
        const w = Math.max(0, (5 + 5 * taper) * (1 - heal));
        if (w < 0.3) continue;
        imgCtx.lineWidth = w;
        imgCtx.beginPath();
        imgCtx.moveTo(pts[i-1].x, pts[i-1].y);
        imgCtx.lineTo(pts[i].x,   pts[i].y);
        imgCtx.stroke();
      }
    }

    // ── Wound glow ────────────────────────────────────────────────────────
    function drawGlow(pts, alpha) {
      const n = pts.length;
      if (n < 2) return;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.lineCap = 'round';
      for (let i = 1; i < n; i++) {
        const taper = Math.min(i / 4, 1, (n - i) / 4);
        const pulse = 0.55 + 0.45 * Math.sin(t * 0.07 + i * 0.6);
        ctx.lineWidth   = 14 + 10 * taper;
        ctx.strokeStyle = 'rgba(180,0,0,' + (0.18 * alpha * pulse).toFixed(3) + ')';
        ctx.shadowBlur  = 22;
        ctx.shadowColor = 'rgba(220,0,0,' + (0.5 * alpha).toFixed(3) + ')';
        ctx.beginPath();
        ctx.moveTo(pts[i-1].x, pts[i-1].y);
        ctx.lineTo(pts[i].x,   pts[i].y);
        ctx.stroke();
      }
      ctx.restore();
    }

    // ── Peeled edge strips ────────────────────────────────────────────────
    function drawPeel(pts, alpha) {
      const n = pts.length;
      if (n < 2) return;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      for (const side of [-1, 1]) {
        const path = [];
        for (let i = 0; i < n; i++) {
          const j  = Math.min(i, n - 2);
          const dx = pts[j+1].x - pts[j].x;
          const dy = pts[j+1].y - pts[j].y;
          const L  = Math.sqrt(dx*dx + dy*dy) || 1;
          const nx = -dy / L, ny = dx / L;
          const taper   = Math.min(i / 5, 1, (n - 1 - i) / 5);
          const flutter = Math.sin(t * 0.05 + i * 0.9 + side * 1.4) * 2.5;
          const off = side * (2 + 9 * taper + flutter);
          path.push({ x: pts[i].x + nx * off, y: pts[i].y + ny * off });
        }
        ctx.lineWidth   = 2.5;
        ctx.strokeStyle = 'rgba(100,8,0,' + (0.85 * alpha).toFixed(3) + ')';
        ctx.shadowBlur  = 5;
        ctx.shadowColor = 'rgba(200,0,0,0.4)';
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
      }
      ctx.restore();
    }

    // ── Flake particles ───────────────────────────────────────────────────
    const flakes = [];

    function Flake(x, y, nx, ny) {
      const s  = Math.random() < 0.5 ? 1 : -1;
      const sp = Math.random() * 1.2 + 0.3;
      this.x  = x;  this.y  = y;
      this.vx = nx*s*sp + (Math.random()-0.5)*0.4;
      this.vy = ny*s*sp + (Math.random()-0.5)*0.4;
      this.a  = Math.atan2(ny, nx);
      this.av = (Math.random()-0.5) * 0.07;
      this.rx = Math.random()*9+3;
      this.ry = Math.random()*1.8+0.4;
      this.life  = 1;
      this.decay = Math.random()*0.005+0.003;
      const r = (40 + Math.random()*70)|0;
      this.fill  = 'rgb(' + r + ',' + ((r*0.05)|0) + ',0)';
    }
    Flake.prototype.step = function() {
      this.vy += 0.015; this.vx *= 0.988; this.vy *= 0.988;
      this.x += this.vx; this.y += this.vy;
      this.a  += this.av; this.life -= this.decay;
    };
    Flake.prototype.draw = function() {
      ctx.save();
      ctx.globalAlpha = Math.max(0, this.life) * 0.65;
      ctx.translate(this.x, this.y); ctx.rotate(this.a);
      ctx.fillStyle = this.fill;
      ctx.beginPath();
      ctx.ellipse(0, 0, this.rx, this.ry, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    };

    function spawnFlakes(p0, p1) {
      const dx = p1.x - p0.x, dy = p1.y - p0.y;
      const L  = Math.sqrt(dx*dx + dy*dy);
      if (L < 1) return;
      const nx = -dy/L, ny = dx/L;
      const n  = Math.ceil(L / 10);
      for (let i = 0; i < n; i++) {
        if (Math.random() < 0.4) {
          const r = i / n;
          flakes.push(new Flake(p0.x+dx*r, p0.y+dy*r, nx, ny));
        }
      }
    }

    // ── Cut management ────────────────────────────────────────────────────
    const cuts    = [];
    const CUT_LIFE = 200;
    const MAX_CUTS = 5;

    function getPos(e) {
      const src = e.touches ? e.touches[0] : e;
      return { x: src.clientX, y: src.clientY };
    }

    canvas.addEventListener('mousedown', function(e) {
      activeCut = { points: [getPos(e)], age: 0 };
      if (!hintGone) { hint.style.opacity = '0'; hintGone = true; }
    });
    canvas.addEventListener('mousemove', function(e) {
      if (!activeCut) return;
      const p = getPos(e), l = activeCut.points[activeCut.points.length - 1];
      const dx = p.x-l.x, dy = p.y-l.y;
      if (dx*dx + dy*dy > 16) { spawnFlakes(l, p); activeCut.points.push(p); }
    });
    canvas.addEventListener('mouseup', function() {
      if (activeCut && activeCut.points.length > 1) {
        if (cuts.length >= MAX_CUTS) cuts.shift();
        cuts.push(activeCut);
      }
      activeCut = null;
    });
    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      activeCut = { points: [getPos(e)], age: 0 };
      if (!hintGone) { hint.style.opacity = '0'; hintGone = true; }
    }, { passive: false });
    canvas.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (!activeCut) return;
      const p = getPos(e), l = activeCut.points[activeCut.points.length - 1];
      const dx = p.x-l.x, dy = p.y-l.y;
      if (dx*dx + dy*dy > 16) { spawnFlakes(l, p); activeCut.points.push(p); }
    }, { passive: false });
    canvas.addEventListener('touchend', function() {
      if (activeCut && activeCut.points.length > 1) {
        if (cuts.length >= MAX_CUTS) cuts.shift();
        cuts.push(activeCut);
      }
      activeCut = null;
    });

    // ── Main loop ─────────────────────────────────────────────────────────
    function loop() {
      t++;
      drawSeething();
      drawImageLayer();

      for (let i = cuts.length - 1; i >= 0; i--) {
        const a = Math.max(0, 1 - cuts[i].age / CUT_LIFE);
        drawPeel(cuts[i].points, a);
        drawGlow(cuts[i].points, a);
        cuts[i].age++;
        if (cuts[i].age >= CUT_LIFE) cuts.splice(i, 1);
      }
      if (activeCut) {
        drawPeel(activeCut.points, 1);
        drawGlow(activeCut.points, 1);
      }

      for (let i = flakes.length - 1; i >= 0; i--) {
        flakes[i].step();
        flakes[i].draw();
        if (flakes[i].life <= 0) flakes.splice(i, 1);
      }

      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
